<?php
/**
 * @file
 * Contains \Drupal\country_path\Plugin\LanguageNegotiation\LanguageNegotiationUrlExtra
 */

namespace Drupal\br_domain\Plugin\LanguageNegotiation;

use Drupal\Core\Language\LanguageInterface;
use Drupal\Core\PathProcessor\InboundPathProcessorInterface;
use Drupal\Core\PathProcessor\OutboundPathProcessorInterface;
use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Url;
use Drupal\domain\ContextProvider\CurrentDomainContext;
use Drupal\domain\DomainInterface;
use Drupal\domain\DomainNegotiatorInterface;
use Drupal\domain\Entity\Domain;
use Drupal\language\LanguageSwitcherInterface;
use Drupal\language\Plugin\LanguageNegotiation\LanguageNegotiationUrl;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\Request;


/**
 * Class for identifying language via URL prefix with domains.
 *
 * @LanguageNegotiation(
 *   id = \Drupal\br_domain\Plugin\LanguageNegotiation\LanguageNegotiationUrlExtra::METHOD_ID,
 *   types = {\Drupal\Core\Language\LanguageInterface::TYPE_INTERFACE,
 *   \Drupal\Core\Language\LanguageInterface::TYPE_CONTENT,
 *   \Drupal\Core\Language\LanguageInterface::TYPE_URL},
 *   weight = -8,
 *   name = @Translation("Prefix extra"),
 *   description = @Translation("Language from the URL (Path prefix). Path prefix position is adjusted for domain module"),
 *   config_route_name = "br_domain.negotiation_url_prefix"
 * )
 */
class LanguageNegotiationUrlExtra extends LanguageNegotiationUrl implements InboundPathProcessorInterface, OutboundPathProcessorInterface, LanguageSwitcherInterface, ContainerFactoryPluginInterface {
  /**
   * The language negotiation method id.
   */
  const METHOD_ID = 'language-url-domain-access';


  protected $domainNegotiator;

  /**
   * Store the languagecode position after getLangcode, so it can be used
   * in the inbound processor to clean the path.
   *
   * @var int
   */
  protected $languageCodePosition = -1;

  public function __construct(DomainNegotiatorInterface $domain_negotiator) {
    $this->domainNegotiator = $domain_negotiator;
  }

  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    $domain_negotiator = $container->get('domain.negotiator');
    return new static($domain_negotiator);
  }


  public function getLangcode(Request $request = NULL) {
    $langcode = NULL;

    if ($request && $this->languageManager) {
      $languages = $this->languageManager->getLanguages();
      $config = $this->config->get('br_domain.language.negotiation')
        ->get('url');

      $request_path = urldecode(trim($request->getPathInfo(), '/'));
      $path_args = explode('/', $request_path);
      $prefix = $path_args[0];
      if ($prefix == 'api') {
        $prefix = $path_args[4];
      }
      else {
        // If there is a domain path, the language prefix should be read from the second argument.
        $current_domain = $this->domainNegotiator->getActiveDomain(TRUE);
        if ($current_domain instanceof DomainInterface && $domain_path = $current_domain->getThirdPartySetting('country_path',
            'domain_path')
        ) {
          if ($domain_path != '') {
            // if there's a language prefix, fetch that, otherwise,
            // allow fallback to default language without causing warnings!
            $prefix = isset($path_args[1]) ? $path_args[1] : '';
          }
        }
      }

      // Search prefix within added languages.
      $negotiated_language = FALSE;
      foreach ($languages as $language) {
        if (isset($config['prefixes'][$language->getId()]) && $config['prefixes'][$language->getId()] == $prefix) {
          $negotiated_language = $language;
          break;
        }
      }

      if ($negotiated_language) {
        $langcode = $negotiated_language->getId();
      }

    }

    return $langcode;
  }

  /**
   * @inheritDoc
   */
  public function processInbound($path, Request $request) {
    return parent::processInbound($path,
      $request); // TODO: Change the autogenerated stub
  }


  public function processOutbound($path, &$options = array(), Request $request = NULL, BubbleableMetadata $bubbleable_metadata = NULL) {
    $url_scheme = 'http';
    $port = 80;
    if ($request) {
      $url_scheme = $request->getScheme();
      $port = $request->getPort();
    }
    $languages = array_flip(array_keys($this->languageManager->getLanguages()));
    // Language can be passed as an option, or we go for current URL language.
    if (!isset($options['language'])) {
      $language_url = $this->languageManager->getCurrentLanguage(LanguageInterface::TYPE_URL);
      $options['language'] = $language_url;
    }
    // We allow only added languages here.
    elseif (!is_object($options['language']) || !isset($languages[$options['language']->getId()])) {
      return $path;
    }
    $config = $this->config->get('br_domain.language.negotiation')->get('url');
    if (is_object($options['language']) && !empty($config['prefixes'][$options['language']->getId()])) {
      $options['prefix'] = $config['prefixes'][$options['language']->getId()] . '/';
      if ($bubbleable_metadata) {
        $bubbleable_metadata->addCacheContexts(['languages:' . LanguageInterface::TYPE_URL]);
      }
    }
    return $path;
  }

  public function getLanguageSwitchLinks(Request $request, $type, Url $url) {
    return parent::getLanguageSwitchLinks($request, $type,
      $url); // TODO: Change the autogenerated stub
  }


}